# COMET模型加载优化指南

## 问题描述

在使用gunicorn多worker模式时，多个worker进程同时加载COMET模型会导致：
- 服务器CPU和内存占用过高
- 系统卡死，完全无响应
- 磁盘I/O竞争（同时读取大文件）

## 解决方案

### 方案1: 减少Worker数量（最简单）

```bash
# 使用1个worker（最安全，但并发性能较低）
gunicorn -w 1 -b 0.0.0.0:5001 --timeout 300 eval_server:app

# 使用2个worker（平衡性能和稳定性）
gunicorn -w 2 -b 0.0.0.0:5001 --timeout 300 eval_server:app
```

**优点**：简单，立即生效  
**缺点**：并发性能降低

### 方案2: 使用预加载模式（推荐）

```bash
# 使用 --preload 选项，所有worker共享同一个模型实例
gunicorn -w 4 -b 0.0.0.0:5001 --timeout 300 --preload eval_server:app
```

**优点**：
- 模型只加载一次（在主进程中）
- 所有worker共享同一个模型实例
- 节省内存，避免重复加载

**缺点**：
- 需要确保模型加载在主进程中完成
- 某些情况下可能有兼容性问题

### 方案3: 使用文件锁机制（已实现）

代码中已实现文件锁机制，确保只有一个进程加载模型，其他进程等待。

**工作原理**：
1. 第一个worker获取锁并加载模型
2. 其他worker等待锁释放
3. 模型加载完成后，其他worker可以继续初始化（但模型已加载，会快速完成）

**优点**：自动处理，无需手动配置  
**缺点**：首次启动时，其他worker需要等待

### 方案4: 延迟初始化（已实现）

模型在首次请求时加载，而不是在worker启动时加载。

**优点**：
- Worker启动更快
- 可以按需加载

**缺点**：
- 首次请求可能较慢

## 推荐配置

### 生产环境（推荐）

```bash
# 使用预加载模式 + 2-4个worker
gunicorn -w 2 -b 0.0.0.0:5001 --timeout 300 --preload eval_server:app
```

### 开发环境

```bash
# 使用1个worker，避免资源竞争
gunicorn -w 1 -b 0.0.0.0:5001 --timeout 300 eval_server:app
```

### 高并发场景

```bash
# 如果必须使用多个worker，建议：
# 1. 使用预加载模式
# 2. 减少worker数量到2-3个
# 3. 使用更大的超时时间
gunicorn -w 2 -b 0.0.0.0:5001 --timeout 600 --preload eval_server:app
```

## 监控和诊断

### 检查系统资源

```bash
# 查看CPU和内存使用
top
# 或
htop

# 查看进程
ps aux | grep gunicorn

# 查看系统负载
uptime
```

### 查看日志

启动时应该看到：
```
🔒 [COMET] 尝试获取模型加载锁: comet_xxx
⏳ [ModelLock] 等待锁释放: comet_xxx (已等待 X秒)
✅ COMET模型已加载
```

如果看到多个worker同时加载，说明锁机制可能未生效。

## 故障排查

### 问题1: 服务器完全卡死

**解决方案**：
1. 减少worker数量到1-2个
2. 使用预加载模式
3. 检查系统内存是否足够（COMET模型需要约2-4GB内存）

### 问题2: 加载时间过长

**解决方案**：
1. 确保使用本地模型路径（避免网络下载）
2. 检查磁盘I/O性能
3. 考虑使用SSD存储模型文件

### 问题3: 内存不足

**解决方案**：
1. 减少worker数量
2. 使用预加载模式（共享模型实例）
3. 增加服务器内存

## 最佳实践

1. **使用预加载模式**：`--preload` 选项可以避免重复加载模型
2. **合理设置worker数量**：根据服务器资源调整，建议2-4个
3. **监控资源使用**：定期检查CPU、内存和磁盘I/O
4. **使用本地模型**：避免网络下载导致的延迟
5. **设置合理的超时**：`--timeout 300` 或更长，给模型加载足够时间
